from __future__ import print_function

import sys
import codecs
from argparse import ArgumentParser

from re2c import transform_grammar, lark2re2c
from re2c.parser import parse


argparser = ArgumentParser(prog='lark.re2c', description='re2c based lexers from Lark grammars.')
argparser.add_argument('grammar', type=str,
                       help='a Lark grammar file')

argparser.add_argument('--re2c', dest='re2c', type=str, metavar='PATH',
                       help='path to the re2c executable file')

group = argparser.add_mutually_exclusive_group()
group.add_argument('-8', '--utf8', dest='utf8', action='store_true', default=True,
                   help='handle input as UTF-8')
group.add_argument('-u', '--unicode', dest='unicode', action='store_true', default=False,
                   help='handle input as UTF-32')
group.add_argument('-b', '--binary', dest='binary', action='store_true', default=False,
                   help='handle input as raw bytes')

group = argparser.add_mutually_exclusive_group()
group.add_argument('--dump-re2c', dest='dump_re2c', action='store_true',
                       help='output the transformed grammar in re2c format')
group.add_argument('--dump-c', dest='dump_c', action='store_true',
                       help='output the generated C code after runnning re2c')
group.add_argument('--dump-fsm', dest='dump_fsm', action='store_true',
                       help='output the generated finite state machine')
group.add_argument('--dump-asm', dest='dump_asm', action='store_true',
                       help='output the generated opcodes')


args = argparser.parse_args()

with codecs.open(args.grammar, encoding='utf8') as fd:
    rules = transform_grammar(fd.read())
    if args.dump_re2c:
        for rule in rules:
            print('{0:60} {{ {1} }}'.format(rule[0], rule[1]))
        sys.exit(0)

    ccode = lark2re2c(rules, binary=args.binary, unicode=args.unicode, re2c_bin=args.re2c)
    if args.dump_c:
        print(ccode)
        sys.exit(0)

    fsm = parse(ccode)
    if args.dump_fsm:
        print(repr(fsm))
        sys.exit(0)

    asm = fsm.assemble('re2c')

    if args.dump_asm:
        print(repr(asm))
        sys.exit(0)

    if args.unicode:
        char_type = 'unicode'
    elif args.binary:
        char_type = 'bytes'
    else:
        char_type = 'bytes'

    print('# Generated by Lark re2c tool')
    print('from functools import partial')
    print('from fsm.assembler import Assembler, Opcode')
    print('from re2c.fsm import build, wrapper')
    print('')
    print('_asm = {}'.format(repr(asm)))
    print('')
    print('try:')
    print('  unicode = unicode')
    print('except:')
    print('  unicode = str')
    print('')
    print('_lex = build(_asm, char_type={})'.format(char_type))
    print('lex = partial(wrapper, _lex)')
